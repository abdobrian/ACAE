<!DOCTYPE html>
<html>
<head>
  <title>README.md</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../doc-style.css" />
  <script src="../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../";
    var thisFile = "ClientApp\\node_modules\\app-root-path\\README.md";
    var defaultSidebar = true;
  </script>
  <script src="../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

      <div class="heading h1">
        <a href="#app-root-path-module">App Root Path Module</a>
      </div>

      <div class="heading h2">
        <a href="#installation">Installation</a>
      </div>

      <div class="heading h2">
        <a href="#usage">Usage</a>
      </div>

      <div class="heading h2">
        <a href="#how-it-works-under-the-hood">How It Works (under the hood)</a>
      </div>

      <div class="heading h3">
        <a href="#primary-method">Primary Method</a>
      </div>

      <div class="heading h3">
        <a href="#secondary-method-for-edge-cases">Secondary Method (for edge cases)</a>
      </div>

      <div class="heading h3">
        <a href="#edge-case-global-clis">Edge-Case: Global CLIs</a>
      </div>

      <div class="heading h2">
        <a href="#change-log">Change Log</a>
      </div>

      <div class="heading h3">
        <a href="#2.0.1">2.0.1</a>
      </div>

      <div class="heading h3">
        <a href="#2.0.0">2.0.0</a>
      </div>

      <div class="heading h3">
        <a href="#1.3.0">1.3.0</a>
      </div>

      <div class="heading h3">
        <a href="#1.2.1">1.2.1</a>
      </div>

      <div class="heading h3">
        <a href="#1.2.0">1.2.0</a>
      </div>

      <div class="heading h3">
        <a href="#1.1.0">1.1.0</a>
      </div>

      <div class="heading h3">
        <a href="#1.0.0">1.0.0</a>
      </div>

      <div class="heading h3">
        <a href="#0.1.1">0.1.1</a>
      </div>

      <div class="heading h3">
        <a href="#0.1.0">0.1.0</a>
      </div>

      <div class="heading h2">
        <a href="#development-nodes">Development Nodes</a>
      </div>

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="docs markdown"><div class="pilwrap" id="app-root-path-module">
  <h1>
    <a href="#app-root-path-module" name="app-root-path-module" class="pilcrow"></a>
App Root Path Module
  </h1>
</div>
<p><a href="https://travis-ci.org/inxilpro/node-app-root-path"><img src="https://travis-ci.org/inxilpro/node-app-root-path.svg" alt="Build Status"></a> <a href="https://david-dm.org/inxilpro/node-app-root-path"><img src="https://david-dm.org/inxilpro/node-app-root-path.svg" alt="Dependency Status"></a> <a href="https://codecov.io/gh/inxilpro/node-app-root-path"><img src="https://codecov.io/gh/inxilpro/node-app-root-path/branch/master/graph/badge.svg" alt="Code Coverage Status"></a></p>
<blockquote>
<p><strong>Please Note:</strong> Due to the very limited scope of this module, I do not anticipate needing to make very many changes to it.  Expect long stretches of zero updates—that does not mean that the module is outdated.</p>
</blockquote>
<p>This simple module helps you access your application's root path from anywhere in the application without resorting to relative paths like <code>require(&quot;../../path&quot;)</code>.</p>
<div class="pilwrap" id="installation">
  <h2>
    <a href="#installation" name="installation" class="pilcrow"></a>
Installation
  </h2>
</div>
<pre><code class="bash">$ npm i -S app-root-path
</code></pre>
<div class="pilwrap" id="usage">
  <h2>
    <a href="#usage" name="usage" class="pilcrow"></a>
Usage
  </h2>
</div>
<p>To simply access the app's root path, use the module as though it were a string:</p>
<pre><code class="js"><span class="hljs-keyword">var</span> appRoot = <span class="hljs-built_in">require</span>(<span class="hljs-string">'app-root-path'</span>);
<span class="hljs-keyword">var</span> myModule = <span class="hljs-built_in">require</span>(appRoot + <span class="hljs-string">'/lib/my-module.js'</span>);
</code></pre>
<blockquote>
<p><em>Side note: the module actually returns an object, but that object implements the <code>toString</code> method, so you can use it as though it were a string.  There are a few edge cases where this might not be the case (most notably <code>console.log</code>), but they shouldn't affect actual use of the module, where you're almost always concatenating with an additional string.</em></p>
</blockquote>
<p>A helper function is also provided:</p>
<pre><code class="js"><span class="hljs-keyword">var</span> reqlib = <span class="hljs-built_in">require</span>(<span class="hljs-string">'app-root-path'</span>).require;
<span class="hljs-keyword">var</span> myModule = reqlib(<span class="hljs-string">'/lib/my-module.js'</span>);
</code></pre>
<p>It's a little hacky, but you can also put this method on your application's <code>global</code> object to use it everywhere in your project:</p>
<pre><code class="js"><span class="hljs-comment">// In app.js</span>
global.reqlib = <span class="hljs-built_in">require</span>(<span class="hljs-string">'app-root-path'</span>).require;

<span class="hljs-comment">// In lib/module/component/subcomponent.js</span>
<span class="hljs-keyword">var</span> myModule = reqlib(<span class="hljs-string">'/lib/my-module.js'</span>);
</code></pre>
<p>Finally, you can also just resolve a module path:</p>
<pre><code class="js"><span class="hljs-keyword">var</span> myModulePath = <span class="hljs-built_in">require</span>(<span class="hljs-string">'app-root-path'</span>).resolve(<span class="hljs-string">'/lib/my-module.js'</span>);
</code></pre>
<p>You can explicitly set the path, using the environmental variable <code>APP_ROOT_PATH</code> or by calling <code>require('app-root-path').setPath('/my/app/is/here')</code></p>
<div class="pilwrap" id="how-it-works-under-the-hood">
  <h2>
    <a href="#how-it-works-under-the-hood" name="how-it-works-under-the-hood" class="pilcrow"></a>
How It Works (under the hood)
  </h2>
</div>
<blockquote>
<p>No need to read this unless your curious—or you run into a (very unlikely) case where the module does not work as expected.</p>
</blockquote>
<p>This module uses two different methods to determine the app's root path, depending on the circumstances.</p>
<div class="pilwrap" id="primary-method">
  <h3>
    <a href="#primary-method" name="primary-method" class="pilcrow"></a>
Primary Method
  </h3>
</div>
<p>If the module is located inside your project's directory, somewhere within the <code>node_modules</code> directory (whether directly, or inside a submodule), we effectively do (the actual code takes cross-platform path names/etc into consideration):</p>
<pre><code class="js">path.resolve(__dirname).split(<span class="hljs-string">'/node_modules'</span>)[<span class="hljs-number">0</span>];
</code></pre>
<p>This will take a path like <code>/var/www/node_modules/submodule/node_modules/app-root-path</code> and return <code>/var/www</code>.  In nearly all cases, this is just what you need.</p>
<div class="pilwrap" id="secondary-method-for-edge-cases">
  <h3>
    <a href="#secondary-method-for-edge-cases" name="secondary-method-for-edge-cases" class="pilcrow"></a>
Secondary Method (for edge cases)
  </h3>
</div>
<p>The node module loader will also look in a few other places for modules (for example, ones that you install globally with <code>npm install -g</code>).  These can be in one of:</p>
<ul>
<li><code>$HOME/.node_modules</code></li>
<li><code>$HOME/.node_libraries</code></li>
<li><code>$PREFIX/lib/node</code></li>
</ul>
<p>Or, anywhere in the <code>NODE_PATH</code> environmental variable (<a href="http://nodejs.org/api/modules.html#modules_loading_from_the_global_folders">see documentation</a>).</p>
<p>In these cases, we fall back to an alternate trick:</p>
<pre><code class="js">path.dirname(<span class="hljs-built_in">require</span>.main.filename);
</code></pre>
<p>When a file is run directly from Node, <code>require.main</code> is set to that file's <code>module</code>.  Each module has a <code>filename</code> property that refers to the filename of that module, so by fetching the directory name for that file, we at least get the directory of file passed to <code>node</code>.  In some cases (process managers and test suites, for example) this doesn't actually give the correct directory, though, so this method is only used as a fallback.</p>
<div class="pilwrap" id="edge-case-global-clis">
  <h3>
    <a href="#edge-case-global-clis" name="edge-case-global-clis" class="pilcrow"></a>
Edge-Case: Global CLIs
  </h3>
</div>
<p>If your module is installed as a global CLI, for example in <code>/usr/local/lib/node_modules/yourmodule</code>, then
<code>require.main.filename</code> will report <code>/usr/local/lib/node_modules/yourmodule/bin</code>, which is probably not what
you want. <code>app-root-path</code> is aware of this edge-case and will strip the <code>/bin</code> automatically.</p>
<div class="pilwrap" id="change-log">
  <h2>
    <a href="#change-log" name="change-log" class="pilcrow"></a>
Change Log
  </h2>
</div>
<div class="pilwrap" id="2.0.1">
  <h3>
    <a href="#2.0.1" name="2.0.1" class="pilcrow"></a>
2.0.1
  </h3>
</div>
<ul>
<li>Minor tweaks to how electron-specific logic runs. Should help with packagers that try to resolve all <code>require()</code> statements during packaging.</li>
</ul>
<div class="pilwrap" id="2.0.0">
  <h3>
    <a href="#2.0.0" name="2.0.0" class="pilcrow"></a>
2.0.0
  </h3>
</div>
<ul>
<li>Removed official support for node &lt; 4.0</li>
<li>Removed support for passing <code>module.require</code> to <code>appRootPath.require</code> (which has been deprecated for a while)</li>
<li>Implemented <a href="https://github.com/semantic-release/semantic-release">semantic-release</a> from here on out</li>
<li>Added browserify-compatible shim</li>
</ul>
<div class="pilwrap" id="1.3.0">
  <h3>
    <a href="#1.3.0" name="1.3.0" class="pilcrow"></a>
1.3.0
  </h3>
</div>
<ul>
<li>Updated <a href="https://github.com/atom/electron">electron</a> to match changes in version 1.0 of that project</li>
</ul>
<div class="pilwrap" id="1.2.1">
  <h3>
    <a href="#1.2.1" name="1.2.1" class="pilcrow"></a>
1.2.1
  </h3>
</div>
<ul>
<li>Had to bump package version because 1.2.0 got published to npm as @beta</li>
</ul>
<div class="pilwrap" id="1.2.0">
  <h3>
    <a href="#1.2.0" name="1.2.0" class="pilcrow"></a>
1.2.0
  </h3>
</div>
<ul>
<li>Special logic to resolve correctly when in an <a href="https://github.com/atom/electron">electron</a> renderer process</li>
</ul>
<div class="pilwrap" id="1.1.0">
  <h3>
    <a href="#1.1.0" name="1.1.0" class="pilcrow"></a>
1.1.0
  </h3>
</div>
<ul>
<li>Special logic to handle an edge case when used in a globally-installed CLI project</li>
<li>Fixed a bug where <code>setPath()</code> did not update <code>require('app-root-path').path</code></li>
<li>Moved some logic outside of the <code>resolve()</code> function so that it's not called multiple times</li>
</ul>
<div class="pilwrap" id="1.0.0">
  <h3>
    <a href="#1.0.0" name="1.0.0" class="pilcrow"></a>
1.0.0
  </h3>
</div>
<ul>
<li>No changes.  Just updated the version to signify a locked API (see <a href="http://semver.org/">semver</a>).</li>
</ul>
<div class="pilwrap" id="0.1.1">
  <h3>
    <a href="#0.1.1" name="0.1.1" class="pilcrow"></a>
0.1.1
  </h3>
</div>
<ul>
<li>Added Windows support (and, theoretically, other operating systems that have a directory separator that's not &quot;/&quot;)</li>
</ul>
<div class="pilwrap" id="0.1.0">
  <h3>
    <a href="#0.1.0" name="0.1.0" class="pilcrow"></a>
0.1.0
  </h3>
</div>
<ul>
<li>Completely rewrote the path resolution method to account for most possible scenarios.  This shouldn't cause and backwards compatibility issues, but always test your code.</li>
<li>Removed the need to pass a modules's <code>require()</code> method to the <code>appRootPath.require()</code> function.  Which it's true that each module has its own <code>require()</code> method, in practice it doesn't matter, and it's <strong>much</strong> simpler this way.</li>
<li>Added tests</li>
</ul>
<div class="pilwrap" id="development-nodes">
  <h2>
    <a href="#development-nodes" name="development-nodes" class="pilcrow"></a>
Development Nodes
  </h2>
</div>
<p>When using <a href="https://github.com/semantic-release/semantic-release">semantic-release</a>, the preferred method
for commits is:</p>
<ul>
<li><code>git add …</code></li>
<li><code>git cz</code> (see <a href="https://github.com/commitizen/cz-cli">commitizen</a>)</li>
<li><code>git push</code></li>
</ul>
<p>This helps ensure that commits match the expected format.  Commits to <code>master</code> will cause releases.</p>
</div>
  </div>
</body>
</html>
