<!DOCTYPE html>
<html>
<head>
  <title>buffer-more-ints-tests.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../doc-style.css" />
  <script src="../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../";
    var thisFile = "ClientApp\\node_modules\\buffer-more-ints\\buffer-more-ints-tests.js";
    var defaultSidebar = true;
  </script>
  <script src="../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>buffer-more-ints-tests.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-built_in">require</span>(<span class="hljs-string">'./polyfill'</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>A simple abbreviation to obtain a buffer from a hex string</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">h2b</span>(<span class="hljs-params">str</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Buffer(str, <span class="hljs-string">"hex"</span>);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<p>Reverse a buffer</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">buf</span>) </span>{
    <span class="hljs-keyword">var</span> res = <span class="hljs-keyword">new</span> Buffer(buf.length);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, j = buf.length - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; i++, j--) {
        res[i] = buf[j];
    }
    <span class="hljs-keyword">return</span> res;
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>Fill a buffer with distinctive data</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scrub</span>(<span class="hljs-params">buf</span>) </span>{
    <span class="hljs-keyword">var</span> pos = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> written;
    <span class="hljs-keyword">while</span> ((written = buf.write(<span class="hljs-string">"deadbeef"</span>, pos, <span class="hljs-number">4</span>, <span class="hljs-string">"hex"</span>)) == <span class="hljs-number">4</span>) {
        pos += written;
    }
    <span class="hljs-keyword">return</span> buf;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">xint_case</span>(<span class="hljs-params">xint</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">assert, hex, val, inexact</span>) </span>{
        <span class="hljs-keyword">var</span> readBE = <span class="hljs-string">"read"</span> + xint + <span class="hljs-string">"BE"</span>;
        <span class="hljs-keyword">var</span> writeBE = <span class="hljs-string">"write"</span> + xint + <span class="hljs-string">"BE"</span>;
        <span class="hljs-keyword">var</span> readLE = <span class="hljs-string">"read"</span> + xint + <span class="hljs-string">"LE"</span>;
        <span class="hljs-keyword">var</span> writeLE = <span class="hljs-string">"write"</span> + xint + <span class="hljs-string">"LE"</span>;

        <span class="hljs-keyword">var</span> len = hex.length / <span class="hljs-number">2</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>Straightforward read cases</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        assert.equal(h2b(hex)[readBE](len, <span class="hljs-number">0</span>), val);
        assert.equal(reverse(h2b(hex))[readLE](len, <span class="hljs-number">0</span>), val);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<p>Test straightforward writes and noAssert writes off the ends of
the buffer</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> buf = scrub(<span class="hljs-keyword">new</span> Buffer(len));
        buf[writeBE](len, val, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">if</span> (!inexact) {
            assert.equal(buf.toString(<span class="hljs-string">"hex"</span>), hex);
        } <span class="hljs-keyword">else</span> {
            assert.equal(buf[readBE](len, <span class="hljs-number">0</span>), val);
        }

        <span class="hljs-keyword">var</span> buf2 = scrub(<span class="hljs-keyword">new</span> Buffer(len));
        buf2[writeBE](len, val, <span class="hljs-number">-1</span>, <span class="hljs-literal">true</span>);
        assert.equal(buf2.slice(<span class="hljs-number">0</span>, len<span class="hljs-number">-1</span>).toString(<span class="hljs-string">"hex"</span>),
                     buf.slice(<span class="hljs-number">1</span>, len).toString(<span class="hljs-string">"hex"</span>));
        scrub(buf2);
        buf2[writeBE](len, val, <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);
        assert.equal(buf2.slice(<span class="hljs-number">1</span>, len).toString(<span class="hljs-string">"hex"</span>),
                     buf.slice(<span class="hljs-number">0</span>, len<span class="hljs-number">-1</span>).toString(<span class="hljs-string">"hex"</span>));

        scrub(buf);
        buf[writeLE](len, val, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">if</span> (!inexact) {
            assert.equal(reverse(buf).toString(<span class="hljs-string">"hex"</span>), hex);
        } <span class="hljs-keyword">else</span> {
            assert.equal(buf[readLE](len, <span class="hljs-number">0</span>), val);
        }

        scrub(buf2);
        buf2[writeLE](len, val, <span class="hljs-number">-1</span>, <span class="hljs-literal">true</span>);
        assert.equal(buf2.slice(<span class="hljs-number">0</span>, len<span class="hljs-number">-1</span>).toString(<span class="hljs-string">"hex"</span>),
                     buf.slice(<span class="hljs-number">1</span>, len).toString(<span class="hljs-string">"hex"</span>));
        scrub(buf2);
        buf2[writeLE](len, val, <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);
        assert.equal(buf2.slice(<span class="hljs-number">1</span>, len).toString(<span class="hljs-string">"hex"</span>),
                     buf.slice(<span class="hljs-number">0</span>, len<span class="hljs-number">-1</span>).toString(<span class="hljs-string">"hex"</span>));

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<p>Accessess off the end of the buffer should throw. Node
doesn't catch negative offsets.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        assert.throws(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ h2b(hex)[readBE](len, <span class="hljs-number">1</span>); })
        assert.throws(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ reverse(h2b(hex))[readLE](len, <span class="hljs-number">1</span>); })
        assert.throws(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ buf[writeBE](len, val, <span class="hljs-number">1</span>); });
        assert.throws(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ buf[writeLE](len, val, <span class="hljs-number">1</span>); });

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<p>Test noAssert reads that stray off the ends of the buffer.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> expect = h2b(<span class="hljs-string">"00"</span>+hex)[readBE](len, <span class="hljs-number">0</span>);
        assert.equal(h2b(hex)[readBE](len, <span class="hljs-number">-1</span>, <span class="hljs-literal">true</span>), expect);
        assert.equals(reverse(h2b(hex))[readLE](len, <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>), expect);

        expect = h2b(hex+<span class="hljs-string">"00"</span>)[readBE](len, <span class="hljs-number">1</span>);
        assert.equal(h2b(hex)[readBE](len, <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>), expect);
        assert.equal(reverse(h2b(hex))[readLE](len, <span class="hljs-number">-1</span>, <span class="hljs-literal">true</span>), expect);
    };
}

<span class="hljs-keyword">var</span> uint_case = xint_case(<span class="hljs-string">"UInt"</span>);
<span class="hljs-keyword">var</span> int_case = xint_case(<span class="hljs-string">"Int"</span>);

<span class="hljs-built_in">module</span>.exports.uint = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">assert</span>) </span>{
    uint_case(assert, <span class="hljs-string">"00"</span>, <span class="hljs-number">0x00</span>);
    uint_case(assert, <span class="hljs-string">"01"</span>, <span class="hljs-number">0x01</span>);
    uint_case(assert, <span class="hljs-string">"ff"</span>, <span class="hljs-number">0xff</span>);

    uint_case(assert, <span class="hljs-string">"0000"</span>, <span class="hljs-number">0x0000</span>);
    uint_case(assert, <span class="hljs-string">"0102"</span>, <span class="hljs-number">0x0102</span>);
    uint_case(assert, <span class="hljs-string">"ffff"</span>, <span class="hljs-number">0xffff</span>);

    uint_case(assert, <span class="hljs-string">"000000"</span>, <span class="hljs-number">0x000000</span>);
    uint_case(assert, <span class="hljs-string">"010203"</span>, <span class="hljs-number">0x010203</span>);
    uint_case(assert, <span class="hljs-string">"ffffff"</span>, <span class="hljs-number">0xffffff</span>);

    uint_case(assert, <span class="hljs-string">"00000000"</span>, <span class="hljs-number">0x00000000</span>);
    uint_case(assert, <span class="hljs-string">"01020304"</span>, <span class="hljs-number">0x01020304</span>);
    uint_case(assert, <span class="hljs-string">"ffffffff"</span>, <span class="hljs-number">0xffffffff</span>);

    uint_case(assert, <span class="hljs-string">"0000000000"</span>, <span class="hljs-number">0x0000000000</span>);
    uint_case(assert, <span class="hljs-string">"0102030405"</span>, <span class="hljs-number">0x0102030405</span>);
    uint_case(assert, <span class="hljs-string">"ffffffffff"</span>, <span class="hljs-number">0xffffffffff</span>);

    uint_case(assert, <span class="hljs-string">"000000000000"</span>, <span class="hljs-number">0x000000000000</span>);
    uint_case(assert, <span class="hljs-string">"010203040506"</span>, <span class="hljs-number">0x010203040506</span>);
    uint_case(assert, <span class="hljs-string">"ffffffffffff"</span>, <span class="hljs-number">0xffffffffffff</span>);

    uint_case(assert, <span class="hljs-string">"00000000000000"</span>, <span class="hljs-number">0x00000000000000</span>);
    uint_case(assert, <span class="hljs-string">"01020304050607"</span>, <span class="hljs-number">0x01020304050607</span>);
    uint_case(assert, <span class="hljs-string">"ffffffffffffff"</span>, <span class="hljs-number">0xffffffffffffff</span>);

    uint_case(assert, <span class="hljs-string">"0000000000000000"</span>, <span class="hljs-number">0x0000000000000000</span>);
    uint_case(assert, <span class="hljs-string">"0102030405060708"</span>, <span class="hljs-number">0x0102030405060708</span>, <span class="hljs-literal">true</span>);
    uint_case(assert, <span class="hljs-string">"ffffffffffffffff"</span>, <span class="hljs-number">0xffffffffffffffff</span>);

    assert.done();
};

<span class="hljs-built_in">module</span>.exports.int = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">assert</span>) </span>{
    int_case(assert, <span class="hljs-string">"00"</span>, <span class="hljs-number">0x00</span>);
    int_case(assert, <span class="hljs-string">"01"</span>, <span class="hljs-number">0x01</span>);
    int_case(assert, <span class="hljs-string">"7f"</span>, <span class="hljs-number">0x7f</span>);
    int_case(assert, <span class="hljs-string">"80"</span>, <span class="hljs-number">-0x80</span>);
    int_case(assert, <span class="hljs-string">"ff"</span>, <span class="hljs-number">-0x01</span>);

    int_case(assert, <span class="hljs-string">"0000"</span>, <span class="hljs-number">0x0000</span>);
    int_case(assert, <span class="hljs-string">"0102"</span>, <span class="hljs-number">0x0102</span>);
    int_case(assert, <span class="hljs-string">"7fff"</span>, <span class="hljs-number">0x7fff</span>);
    int_case(assert, <span class="hljs-string">"8000"</span>, <span class="hljs-number">-0x8000</span>);
    int_case(assert, <span class="hljs-string">"ffff"</span>, <span class="hljs-number">-0x0001</span>);

    int_case(assert, <span class="hljs-string">"000000"</span>, <span class="hljs-number">0x000000</span>);
    int_case(assert, <span class="hljs-string">"010203"</span>, <span class="hljs-number">0x010203</span>);
    int_case(assert, <span class="hljs-string">"7fffff"</span>, <span class="hljs-number">0x7fffff</span>);
    int_case(assert, <span class="hljs-string">"800000"</span>, <span class="hljs-number">-0x800000</span>);
    int_case(assert, <span class="hljs-string">"ffffff"</span>, <span class="hljs-number">-0x000001</span>);

    int_case(assert, <span class="hljs-string">"00000000"</span>, <span class="hljs-number">0x00000000</span>);
    int_case(assert, <span class="hljs-string">"01020304"</span>, <span class="hljs-number">0x01020304</span>);
    int_case(assert, <span class="hljs-string">"7fffffff"</span>, <span class="hljs-number">0x7fffffff</span>);
    int_case(assert, <span class="hljs-string">"80000000"</span>, <span class="hljs-number">-0x80000000</span>);
    int_case(assert, <span class="hljs-string">"ffffffff"</span>, <span class="hljs-number">-0x00000001</span>);

    int_case(assert, <span class="hljs-string">"0000000000"</span>, <span class="hljs-number">0x0000000000</span>);
    int_case(assert, <span class="hljs-string">"0102030405"</span>, <span class="hljs-number">0x0102030405</span>);
    int_case(assert, <span class="hljs-string">"7fffffffff"</span>, <span class="hljs-number">0x7fffffffff</span>);
    int_case(assert, <span class="hljs-string">"8000000000"</span>, <span class="hljs-number">-0x8000000000</span>);
    int_case(assert, <span class="hljs-string">"ffffffffff"</span>, <span class="hljs-number">-0x0000000001</span>);

    int_case(assert, <span class="hljs-string">"000000000000"</span>, <span class="hljs-number">0x000000000000</span>);
    int_case(assert, <span class="hljs-string">"010203040506"</span>, <span class="hljs-number">0x010203040506</span>);
    int_case(assert, <span class="hljs-string">"7fffffffffff"</span>, <span class="hljs-number">0x7fffffffffff</span>);
    int_case(assert, <span class="hljs-string">"800000000000"</span>, <span class="hljs-number">-0x800000000000</span>);
    int_case(assert, <span class="hljs-string">"ffffffffffff"</span>, <span class="hljs-number">-0x000000000001</span>);

    int_case(assert, <span class="hljs-string">"00000000000000"</span>, <span class="hljs-number">0x00000000000000</span>);
    int_case(assert, <span class="hljs-string">"01020304050607"</span>, <span class="hljs-number">0x01020304050607</span>);
    int_case(assert, <span class="hljs-string">"7fffffffffffff"</span>, <span class="hljs-number">0x7fffffffffffff</span>);
    int_case(assert, <span class="hljs-string">"80000000000000"</span>, <span class="hljs-number">-0x80000000000000</span>);
    int_case(assert, <span class="hljs-string">"ffffffffffffff"</span>, <span class="hljs-number">-0x00000000000001</span>);

    int_case(assert, <span class="hljs-string">"0000000000000000"</span>, <span class="hljs-number">0x0000000000000000</span>);
    int_case(assert, <span class="hljs-string">"0102030405060708"</span>, <span class="hljs-number">0x0102030405060708</span>, <span class="hljs-literal">true</span>);
    int_case(assert, <span class="hljs-string">"7fffffffffffffff"</span>, <span class="hljs-number">0x7fffffffffffffff</span>);
    int_case(assert, <span class="hljs-string">"8000000000000000"</span>, <span class="hljs-number">-0x8000000000000000</span>);
    int_case(assert, <span class="hljs-string">"ffffffffffffffff"</span>, <span class="hljs-number">-0x0000000000000001</span>);

    assert.done();
};

<span class="hljs-built_in">module</span>.exports.isContiguousInt = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">assert</span>) </span>{
    assert.equal(Buffer.isContiguousInt(<span class="hljs-number">0x1fffffffffffff</span>), <span class="hljs-literal">true</span>);
    assert.equal(Buffer.isContiguousInt(<span class="hljs-number">0x20000000000000</span>), <span class="hljs-literal">false</span>);
    assert.equal(Buffer.isContiguousInt(<span class="hljs-number">-0x1fffffffffffff</span>), <span class="hljs-literal">true</span>);
    assert.equal(Buffer.isContiguousInt(<span class="hljs-number">-0x20000000000000</span>), <span class="hljs-literal">false</span>);

    assert.doesNotThrow(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        Buffer.assertContiguousInt(<span class="hljs-number">0x1fffffffffffff</span>);
    });
    assert.throws(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        Buffer.assertContiguousInt(<span class="hljs-number">0x20000000000000</span>);
    });
    assert.doesNotThrow(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        Buffer.assertContiguousInt(<span class="hljs-number">-0x1fffffffffffff</span>);
    });
    assert.throws(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        Buffer.assertContiguousInt(<span class="hljs-number">-0x20000000000000</span>);
    });

    assert.done();
};

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
