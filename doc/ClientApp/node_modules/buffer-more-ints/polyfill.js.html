<!DOCTYPE html>
<html>
<head>
  <title>polyfill.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../doc-style.css" />
  <script src="../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../";
    var thisFile = "ClientApp\\node_modules\\buffer-more-ints\\polyfill.js";
    var defaultSidebar = true;
  </script>
  <script src="../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>polyfill.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-meta">'use strict'</span>;

<span class="hljs-keyword">var</span> bmi = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./buffer-more-ints'</span>);

Buffer.isContiguousInt = bmi.isContiguousInt;
Buffer.assertContiguousInt = bmi.assertContiguousInt;

[<span class="hljs-string">'UInt'</span>, <span class="hljs-string">'Int'</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">signed</span>) </span>{
    [<span class="hljs-string">'24'</span>, <span class="hljs-string">'40'</span>, <span class="hljs-string">'48'</span>, <span class="hljs-string">'56'</span>, <span class="hljs-string">'64'</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">size</span>) </span>{
        [<span class="hljs-string">'BE'</span>, <span class="hljs-string">'LE'</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">endian</span>) </span>{
            <span class="hljs-keyword">var</span> read = <span class="hljs-string">'read'</span> + signed + size + endian;
            <span class="hljs-keyword">var</span> reader = bmi[read];
            Buffer.prototype[read] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">offset, noAssert</span>) </span>{
                <span class="hljs-keyword">return</span> reader(<span class="hljs-keyword">this</span>, offset, noAssert);
            };
            <span class="hljs-keyword">var</span> write = <span class="hljs-string">'write'</span> + signed + size + endian;
            <span class="hljs-keyword">var</span> writer = bmi[write];
            Buffer.prototype[write] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val, offset, noAssert</span>) </span>{
                writer(<span class="hljs-keyword">this</span>, val, offset, noAssert);
            };
        });
    });
});

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>Buffer.prototype.read{UInt,Int}8 returns undefined if the offset is
outside of the buffer, unlike for other widths.  These functions
make it consistent with the others.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> consistent_readX8 = {
    <span class="hljs-attr">readUInt8</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">offset, noAssert</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.readUInt8(offset, noAssert) || <span class="hljs-number">0</span>;
    },
    <span class="hljs-attr">readInt8</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">offset, noAssert</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.readInt8(offset, noAssert) || <span class="hljs-number">0</span>;
    }
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">make_accessor</span>(<span class="hljs-params">read, prefix, suffix</span>) </span>{
    <span class="hljs-keyword">var</span> accessors = [<span class="hljs-literal">false</span>,
                    (read ? consistent_readX8 : Buffer.prototype)[prefix + <span class="hljs-number">8</span>]];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">16</span>; i &lt;= <span class="hljs-number">64</span>; i += <span class="hljs-number">8</span>) {
        accessors.push(Buffer.prototype[prefix + i + suffix]);
    }

    <span class="hljs-keyword">if</span> (read) {
        Buffer.prototype[prefix + suffix] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">len, offset, noAssert</span>) </span>{
            <span class="hljs-keyword">var</span> reader = accessors[len];
            <span class="hljs-keyword">if</span> (reader) {
                <span class="hljs-keyword">return</span> reader.call(<span class="hljs-keyword">this</span>, offset, noAssert);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Cannot read integer of length "</span> + len);
            }
        };
    } <span class="hljs-keyword">else</span> {
        Buffer.prototype[prefix + suffix] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">len, val, offset, noAssert</span>) </span>{
            <span class="hljs-keyword">var</span> writer = accessors[len];
            <span class="hljs-keyword">if</span> (writer) {
                <span class="hljs-keyword">return</span> writer.call(<span class="hljs-keyword">this</span>, val, offset, noAssert);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Cannot write integer of length "</span> + len);
            }
        }
    }
}

[<span class="hljs-string">'UInt'</span>, <span class="hljs-string">'Int'</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">t</span>) </span>{
    [<span class="hljs-string">'BE'</span>, <span class="hljs-string">'LE'</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{
        make_accessor(<span class="hljs-literal">true</span>, <span class="hljs-string">"read"</span> + t, e);
        make_accessor(<span class="hljs-literal">false</span>, <span class="hljs-string">"write"</span> + t, e);
    });
});

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
