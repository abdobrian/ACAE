<!DOCTYPE html>
<html>
<head>
  <title>fetch.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../doc-style.css" />
  <script src="../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../";
    var thisFile = "ClientApp\\node_modules\\domain-task\\fetch.js";
    var defaultSidebar = true;
  </script>
  <script src="../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>fetch.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-meta">"use strict"</span>;
<span class="hljs-built_in">Object</span>.defineProperty(exports, <span class="hljs-string">"__esModule"</span>, { <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span> });
<span class="hljs-keyword">var</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">"url"</span>);
<span class="hljs-keyword">var</span> isAbsoluteUrl = <span class="hljs-built_in">require</span>(<span class="hljs-string">"is-absolute-url"</span>);
<span class="hljs-keyword">var</span> main_1 = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./main"</span>);
<span class="hljs-keyword">var</span> isomorphicFetch = <span class="hljs-built_in">require</span>(<span class="hljs-string">'isomorphic-fetch'</span>);
<span class="hljs-keyword">var</span> isNode = <span class="hljs-keyword">typeof</span> process === <span class="hljs-string">'object'</span> &amp;&amp; process.versions &amp;&amp; !!process.versions.node;
<span class="hljs-keyword">var</span> nodeHttps = isNode &amp;&amp; <span class="hljs-built_in">require</span>(<span class="hljs-string">'https'</span>);
<span class="hljs-keyword">var</span> isHttpsRegex = <span class="hljs-regexp">/^https\:/</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">issueRequest</span>(<span class="hljs-params">baseUrl, req, init</span>) </span>{
    <span class="hljs-keyword">var</span> reqUrl = (req <span class="hljs-keyword">instanceof</span> Request) ? req.url : req;
    <span class="hljs-keyword">var</span> isRelativeUrl = reqUrl &amp;&amp; !isAbsoluteUrl(reqUrl);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<p>Resolve relative URLs</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (baseUrl) {
        <span class="hljs-keyword">if</span> (req <span class="hljs-keyword">instanceof</span> Request) {
            <span class="hljs-keyword">var</span> reqAsRequest = req;
            reqAsRequest.url = url.resolve(baseUrl, reqAsRequest.url);
        }
        <span class="hljs-keyword">else</span> {
            req = url.resolve(baseUrl, req);
        }
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isNode) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<p>TODO: Consider only throwing if it's a relative URL, since absolute ones would work fine</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"\n            When running outside the browser (e.g., in Node.js), you must specify a base URL\n            before invoking domain-task's 'fetch' wrapper.\n            Example:\n                import { baseUrl } from 'domain-task/fetch';\n                baseUrl('http://example.com'); // Relative URLs will be resolved against this\n        "</span>);
    }
    init = applyHttpsAgentPolicy(init, isRelativeUrl, baseUrl);
    <span class="hljs-keyword">return</span> isomorphicFetch(req, init);
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">applyHttpsAgentPolicy</span>(<span class="hljs-params">init, isRelativeUrl, baseUrl</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>HTTPS is awkward in Node because it uses a built-in list of CAs, rather than recognizing
the OS's system-level CA list. There are dozens of issues filed against Node about this,
but still (as of v8.0.0) no resolution besides manually duplicating your CA config.</p>
<p>The biggest problem for typical isomorphic-SPA development this causes is that if you're
using a self-signed localhost cert in development, Node won't be able to make API calls
to it (e.g., https://github.com/aspnet/JavaScriptServices/issues/1089). Developers could
fix this by either manually configuring the cert in Node (which is extremely inconvenient,
especially if multiple devs on a team have different self-signed localhost certs), or by
disabling cert verification on their API requests.</p>
<p>Fortunately, 'domain-task/fetch' knows when you're making a relative-URL request to your
own web server (as opposed to an arbitrary request to anywhere else). In this specific case,
there's no real point in cert verification, since the request never even leaves the machine
so a MitM attack isn't meaningful. So by default, when your code is running in Node and
is making a relative-URL request, <em>and</em> if you haven't explicitly configured any option
for 'agent' (which would let you set up other HTTPS-handling policies), then we automatically
disable cert verification for that request.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (isNode &amp;&amp; isRelativeUrl) {
        <span class="hljs-keyword">var</span> isHttps = baseUrl &amp;&amp; isHttpsRegex.test(baseUrl);
        <span class="hljs-keyword">if</span> (isHttps) {
            <span class="hljs-keyword">var</span> hasAgentConfig = init &amp;&amp; (<span class="hljs-string">'agent'</span> <span class="hljs-keyword">in</span> init);
            <span class="hljs-keyword">if</span> (!hasAgentConfig) {
                <span class="hljs-keyword">var</span> agentForRequest = <span class="hljs-keyword">new</span> (nodeHttps.Agent)({ <span class="hljs-attr">rejectUnauthorized</span>: <span class="hljs-literal">false</span> });
                init = init || {};
                init.agent = agentForRequest;
            }
        }
    }
    <span class="hljs-keyword">return</span> init;
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetch</span>(<span class="hljs-params">url, init</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>As of domain-task 2.0.0, we no longer auto-add the 'fetch' promise to the current domain task list.
This is because it's misleading to do so, and can result in race-condition bugs, e.g.,
https://github.com/aspnet/JavaScriptServices/issues/166</p>
<p>Consider this usage:</p>
<p>import { fetch } from 'domain-task/fetch';
fetch(something).then(callback1).then(callback2) ...etc... .then(data =&gt; updateCriticalAppState);</p>
<p>If we auto-add the very first 'fetch' promise to the domain task list, then the domain task completion
callback might fire at any point among all the chained callbacks. If there are enough chained callbacks,
it's likely to occur before the final 'updateCriticalAppState' one. Previously we thought it was enough
for domain-task to use setTimeout(..., 0) so that its action occurred after all synchronously-scheduled
chained promise callbacks, but this turns out not to be the case. Current versions of Node will run
setTimeout-scheduled callbacks <em>before</em> setImmediate ones, if their timeout has elapsed. So even if you
use setTimeout(..., 10), then this callback will run before setImmediate(...) if there were 10ms or more
of CPU-blocking activity. In other words, a race condition.</p>
<p>The correct design is for the final chained promise to be the thing added to the domain task list, but
this can only be done by the developer and not baked into the 'fetch' API. The developer needs to write
something like:</p>
<p>var myTask = fetch(something).then(callback1).then(callback2) ...etc... .then(data =&gt; updateCriticalAppState);
addDomainTask(myTask);</p>
<p>... so that the domain-tasks-completed callback never fires until after 'updateCriticalAppState'.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> issueRequest(main_1.baseUrl(), url, init);
}
exports.fetch = fetch;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<p>Re-exporting baseUrl from this module for back-compatibility only
Newer code that wants to access baseUrl should use the version exported from the root of this package</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> main_2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./main"</span>);
exports.baseUrl = main_2.baseUrl;

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
