<!DOCTYPE html>
<html>
<head>
  <title>README.md</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../doc-style.css" />
  <script src="../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../";
    var thisFile = "ClientApp\\node_modules\\bitsyntax\\README.md";
    var defaultSidebar = true;
  </script>
  <script src="../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

      <div class="heading h1">
        <a href="#byte-wise-matching-for-node.js">Byte-wise matching for Node.JS</a>
      </div>

      <div class="heading h2">
        <a href="#api">API</a>
      </div>

      <div class="heading h3">
        <a href="#matcher">matcher</a>
      </div>

      <div class="heading h3">
        <a href="#parse-and-match">parse and match</a>
      </div>

      <div class="heading h3">
        <a href="#builder">builder</a>
      </div>

      <div class="heading h3">
        <a href="#build">build</a>
      </div>

      <div class="heading h3">
        <a href="#write">write</a>
      </div>

      <div class="heading h2">
        <a href="#patterns">Patterns</a>
      </div>

      <div class="heading h3">
        <a href="#variable-or-value">Variable or value</a>
      </div>

      <div class="heading h3">
        <a href="#size-and-unit">Size and unit</a>
      </div>

      <div class="heading h3">
        <a href="#type-name-specifier">Type name specifier</a>
      </div>

      <div class="heading h3">
        <a href="#endianness-specifier">Endianness specifier</a>
      </div>

      <div class="heading h3">
        <a href="#signedness-specifier">Signedness specifier</a>
      </div>

      <div class="heading h3">
        <a href="#literal-strings">Literal strings</a>
      </div>

      <div class="heading h2">
        <a href="#examples">Examples</a>
      </div>

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="docs markdown"><div class="pilwrap" id="byte-wise-matching-for-node.js">
  <h1>
    <a href="#byte-wise-matching-for-node.js" name="byte-wise-matching-for-node.js" class="pilcrow"></a>
Byte-wise matching for Node.JS
  </h1>
</div>
<p><a href="https://travis-ci.org/squaremo/bitsyntax-js"><img src="https://travis-ci.org/squaremo/bitsyntax-js.png?branch=master" alt="Build Status"></a></p>
<p>Gives a compact syntax for parsing and constructing byte buffers,
derived from <a href="http://www.erlang.org/doc/programming_examples/bit_syntax.html#id64858">Erlang's bit
syntax</a>.</p>
<pre><code class="js"><span class="hljs-keyword">var</span> bitsyntax = <span class="hljs-built_in">require</span>(<span class="hljs-string">'bitsyntax'</span>);
<span class="hljs-keyword">var</span> pattern = bitsyntax.matcher(<span class="hljs-string">'len:8/integer, str:len/binary'</span>);
<span class="hljs-keyword">var</span> bound = pattern(<span class="hljs-keyword">new</span> Buffer([<span class="hljs-number">4</span>, <span class="hljs-number">0x41</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x43</span>, <span class="hljs-number">0x44</span>]));
bound.str
<span class="hljs-comment">// =&gt; &lt;Buffer 41 42 43 44&gt;</span>
</code></pre>
<p>A typical use of this is parsing byte streams from sockets. For
example, size-prefixed frames:</p>
<pre><code class="js"><span class="hljs-keyword">var</span> framePattern = bitsyntax.matcher(<span class="hljs-string">'len:32/integer, frame:len/binary, rest/binary'</span>);
socket.on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">process</span>(<span class="hljs-params">data</span>) </span>{
  <span class="hljs-keyword">var</span> m;
  <span class="hljs-keyword">if</span> (m = framePattern(data)) {
    emit(<span class="hljs-string">'frame'</span>, m.frame);
    process(m.rest);
  }
  <span class="hljs-keyword">else</span> {
    stashForNextData(data);
  }
});
</code></pre>
<p>Patterns can also be used to construct byte buffers from supplied
values:</p>
<pre><code class="js"><span class="hljs-keyword">var</span> spdyDataFrame = <span class="hljs-built_in">require</span>(<span class="hljs-string">'bitsyntax'</span>)
  .builder(<span class="hljs-string">'streamId:32, flags:8, length:24, data/binary'</span>);

spdyDataFrame({<span class="hljs-attr">streamId</span>:<span class="hljs-number">5</span>, <span class="hljs-attr">flags</span>:<span class="hljs-number">0</span>, <span class="hljs-attr">length</span>:bin.length, <span class="hljs-attr">data</span>:bin});
</code></pre>
<p>One or more segments of a pattern may also be supplied in multiple
arguments, if that is more convenient; this makes it easier to split a
long pattern over lines:</p>
<pre><code class="js"><span class="hljs-keyword">var</span> p = bitsyntax.matcher(<span class="hljs-string">'size:8, payload:size/binary'</span>,
                          <span class="hljs-string">'rest/binary'</span>);
</code></pre>
<div class="pilwrap" id="api">
  <h2>
    <a href="#api" name="api" class="pilcrow"></a>
API
  </h2>
</div>
<div class="pilwrap" id="matcher">
  <h3>
    <a href="#matcher" name="matcher" class="pilcrow"></a>
<code>matcher</code>
  </h3>
</div>
<p>Compiles a pattern as a string (or strings), to a function that will
return either a map of bindings, or <code>false</code>, given a buffer and
optionally an environment. The environment contains values for bound
variables in the pattern (if there are any).</p>
<pre><code class="js"><span class="hljs-keyword">var</span> p = bitsyntax.matcher(<span class="hljs-string">'header:headerSize/binary, rest/binary'</span>);
<span class="hljs-keyword">var</span> b = p(<span class="hljs-keyword">new</span> Buffer([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]), {<span class="hljs-attr">headerSize</span>: <span class="hljs-number">3</span>});
b.header
<span class="hljs-comment">// =&gt; &lt;Buffer 01 02 03&gt;</span>
</code></pre>
<p>A matcher will return <code>false</code> if the supplied buffer does not match
the pattern; for example, if it has too few bytes, or a literal is not
present.</p>
<pre><code class="js"><span class="hljs-keyword">var</span> p = bitsyntax.matcher(<span class="hljs-string">'"foo=", str/binary'</span>);
p(<span class="hljs-keyword">new</span> Buffer(<span class="hljs-string">"bar=humbug"</span>));
<span class="hljs-comment">// =&gt; false</span>
</code></pre>
<div class="pilwrap" id="parse-and-match">
  <h3>
    <a href="#parse-and-match" name="parse-and-match" class="pilcrow"></a>
<code>parse</code> and <code>match</code>
  </h3>
</div>
<p>When composed, equivalent to <code>matcher</code>; may be useful if you want to
examine the internal structure of patterns.</p>
<p><code>parse</code> takes strings as for <code>matcher</code>, and returns the internal
representation of the pattern. <code>match</code> takes this representation, a
buffer, and optionally an environment, and returns the bindings or
<code>false</code> (as with <code>matcher</code>).</p>
<pre><code class="js"><span class="hljs-keyword">var</span> p = bitsyntax.parse(<span class="hljs-string">'header:headerSize/binary'</span>,
                        <span class="hljs-string">'rest/binary'</span>);
<span class="hljs-keyword">var</span> b = bitsyntax.match(p, <span class="hljs-keyword">new</span> Buffer([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]),
                          {<span class="hljs-attr">headerSize</span>: <span class="hljs-number">3</span>});
b.header
<span class="hljs-comment">// =&gt; &lt;Buffer 01 02 03&gt;</span>
</code></pre>
<div class="pilwrap" id="builder">
  <h3>
    <a href="#builder" name="builder" class="pilcrow"></a>
<code>builder</code>
  </h3>
</div>
<p>Takes a pattern and returns a function that will construct a byte
buffer, given values for the variables mentioned in the pattern.</p>
<pre><code class="js"><span class="hljs-keyword">var</span> cons = bitsyntax.builder(<span class="hljs-string">'size:8, bin/binary'</span>);
cons({<span class="hljs-attr">size</span>:<span class="hljs-number">6</span>, <span class="hljs-attr">bin</span>:<span class="hljs-keyword">new</span> Buffer(<span class="hljs-string">'foobar'</span>)});
<span class="hljs-comment">// =&gt; &lt;Buffer 06 66 6f 6f 62 61 72&gt;</span>
</code></pre>
<p>Patterns supplied to builders are slightly different to patterns
supplied for matching, as noted below.</p>
<div class="pilwrap" id="build">
  <h3>
    <a href="#build" name="build" class="pilcrow"></a>
<code>build</code>
  </h3>
</div>
<p>Takes a parsed pattern and a map of variable values, and returns a
buffer. As with <code>match</code>, may be useful to debug patterns.</p>
<pre><code class="js"><span class="hljs-keyword">var</span> pattern = bitsyntax.parse(<span class="hljs-string">'size:8, bin:size/binary'</span>);
bitsyntax.build(pattern, {<span class="hljs-attr">size</span>:<span class="hljs-number">6</span>, <span class="hljs-attr">bin</span>: <span class="hljs-keyword">new</span> Buffer(<span class="hljs-string">'foobar'</span>)});
<span class="hljs-comment">// =&gt; &lt;Buffer 06 66 6f 6f 62 61 72&gt;</span>
</code></pre>
<div class="pilwrap" id="write">
  <h3>
    <a href="#write" name="write" class="pilcrow"></a>
<code>write</code>
  </h3>
</div>
<p>Writes variable values into a buffer, at an offset, according to the
parsed pattern given. Returns the finishing offset, i.e., the supplied
offset plus the number of bytes written.</p>
<pre><code class="js"><span class="hljs-keyword">var</span> pattern = bitsyntax.parse(<span class="hljs-string">'size:8, bin/binary'</span>);
<span class="hljs-keyword">var</span> buf = <span class="hljs-keyword">new</span> Buffer(<span class="hljs-number">7</span>);
bitsyntax.write(buf, <span class="hljs-number">0</span>, pattern,
                {<span class="hljs-attr">size</span>:<span class="hljs-number">6</span>, <span class="hljs-attr">bin</span>: <span class="hljs-keyword">new</span> Buffer(<span class="hljs-string">'foobar'</span>)});
<span class="hljs-comment">// =&gt; 7</span>
buf
<span class="hljs-comment">// =&gt; &lt;Buffer 06 66 6f 6f 62 61 72&gt;</span>
</code></pre>
<div class="pilwrap" id="patterns">
  <h2>
    <a href="#patterns" name="patterns" class="pilcrow"></a>
Patterns
  </h2>
</div>
<p>Patterns are sequences of segments, each matching a value. Segments
have the general form</p>
<pre><code> value:size/type_specifier_list
</code></pre>
<p>The size and type specifier list may be omitted, giving three extra
variations:</p>
<pre><code>value
value:size
value/type_specifier_list
</code></pre>
<p>The type specifier list is a list of keywords separated by
hyphens. Type specifiers are described below.</p>
<p>Patterns are generally supplied as strings, with a comma-separated
series of segments.</p>
<div class="pilwrap" id="variable-or-value">
  <h3>
    <a href="#variable-or-value" name="variable-or-value" class="pilcrow"></a>
Variable or value
  </h3>
</div>
<p>The first part of a segment gives a variable name or a literal
value. If a variable name is given, the value matched by the segment
will be bound to that variable name for the rest of the pattern. If a
literal value is given, the matched value must equal that value. If a
variable's value is given in the environment, the matched value must
equal the provided value.</p>
<p>When used in a builder, the literal value will be copied into the
buffer according to the type it is given. A variable name indicates a
slot into which a value supplied to the builder will be copied.</p>
<p>The special variable name <code>_</code> discards the value matched; i.e., it
simply skips over the appropriate number of bits in the input. '_' is
not allowed in builder patterns.</p>
<div class="pilwrap" id="size-and-unit">
  <h3>
    <a href="#size-and-unit" name="size-and-unit" class="pilcrow"></a>
Size and unit
  </h3>
</div>
<p>The size of a segment is given following the value or variable,
separated with a colon:</p>
<pre><code>foo:32
</code></pre>
<p>The unit is given in the list of specifiers as `'unit' and
an integer from 0..256, separated by a colon:</p>
<pre><code>foo:4/integer-unit:8
</code></pre>
<p>The size is the number of units in the value; the unit is given as a
number of bits. Unit can be of use, for example, when you want to
match integers of a number of bytes rather than a number of bits.</p>
<p>For integers and floats, the default unit is 1 bit; to keep things
aligned on byte boundaries, <code>unit * size</code> must currently be a multiple
of 8. For binaries the default unit is 8, and the unit must be a
multiple of 8.</p>
<p>If the size is omitted and the type is integer, the size defaults to</p>
<ol start="8">
<li>If the size is omitted and the type is binary, the segment will
match all remaining bytes in the input; such a segment may only be
used at the end of a pattern, when matching.</li>
</ol>
<p>The size may also be given as an integer variable matched earlier in
the pattern, as in the example given at the top. When constructing, a
size may be a variable referring to the supplied environment.</p>
<p>In builders, numbers will be rounded, masked or padded to fit the size
and units given; for example, <code>'256:8'</code> gives the binary <code>Buffer&lt;00&gt;</code>
because the lowest eight bits are 0; <code>'255:16</code> gives the binary
<code>Buffer&lt;00 ff&gt;</code>.</p>
<div class="pilwrap" id="type-name-specifier">
  <h3>
    <a href="#type-name-specifier" name="type-name-specifier" class="pilcrow"></a>
Type name specifier
  </h3>
</div>
<p>One of <code>integer</code>, <code>binary</code>, <code>string</code>, <code>float</code>. If not given, the
default is <code>integer</code>.</p>
<p>An integer is a big- or little-endian, signed or unsigned
integer. Integers up to 32 bits are supported. Signed integers are
two's complement format. In JavaScript, only integers between -(2^53)
and 2^53 can be represented, and bitwise operators are only defined on
32-bit signed integers.</p>
<p>A binary is simply a byte buffer; usually this will result in a slice
of the input buffer being returned, so beware mutation.</p>
<p>A string is a UTF8 string consisting of the given number of bytes.</p>
<p>A float is a 32- or 64-bit IEEE754 floating-point value (this is the
standard JavaScript uses, as do Java and Erlang).</p>
<div class="pilwrap" id="endianness-specifier">
  <h3>
    <a href="#endianness-specifier" name="endianness-specifier" class="pilcrow"></a>
Endianness specifier
  </h3>
</div>
<p>Integers may be big- or little-endian; this refers to which 'end' of
the bytes making up the integer are most significant. In network
protocols integers are usually big-endian, meaning the first
(left-most) byte is the most significant, but this is not always the
case.</p>
<p>A specifier of <code>big</code> means the integer will be parsed (or written into
the result) as big-endian, and <code>little</code> means the integer will be
parsed or written as little-endian. The default is big-endian.</p>
<div class="pilwrap" id="signedness-specifier">
  <h3>
    <a href="#signedness-specifier" name="signedness-specifier" class="pilcrow"></a>
Signedness specifier
  </h3>
</div>
<p>Integer segments may include a specifier of <code>signed</code> or <code>unsigned</code>. A
signed integer is parsed as two's complement format. The default is
unsigned.</p>
<p>Signedness is ignored in builders.</p>
<div class="pilwrap" id="literal-strings">
  <h3>
    <a href="#literal-strings" name="literal-strings" class="pilcrow"></a>
Literal strings
  </h3>
</div>
<p>A quoted string appearing in a pattern is a shorthand for the bytes in
its UTF8 encoding. For example,</p>
<pre><code>&quot;foobar&quot;, _/binary
</code></pre>
<p>matches any buffer that starts with the bytes <code>0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72</code>.</p>
<p>When used in a builder, a quoted string is copied into the result as
the bytes of its UTF8 encoding.</p>
<div class="pilwrap" id="examples">
  <h2>
    <a href="#examples" name="examples" class="pilcrow"></a>
Examples
  </h2>
</div>
<p>In the following the matched bytes are given in array notation for
convenience. Bear in mind that <code>match()</code> actually takes a buffer for
the bytes to match against. The phrase &quot;returns X as Y&quot; or &quot;binds X as
Y&quot; means the return value is an object with value X mapped to the key
Y.</p>
<pre><code>54
</code></pre>
<p>Matches the single byte <code>54</code>.</p>
<pre><code>54:32
</code></pre>
<p>Matches the bytes [0,0,0,54].</p>
<pre><code>54:32/little
</code></pre>
<p>Matches the bytes [54,0,0,0].</p>
<pre><code>54:4/unit:8
</code></pre>
<p>Matches the bytes [0,0,0,54].</p>
<pre><code>int:32/signed
</code></pre>
<p>Matches a binary of four bytes, and returns a signed 32-bit integer as
<code>int</code>.</p>
<pre><code>len:16, str:len/binary
</code></pre>
<p>Matches a binary of <code>2 + len</code> bytes, and returns an unsigned 16-bit
integer as <code>len</code> and a buffer of length <code>len</code> as <code>str</code>.</p>
<pre><code>len:16, _:len/binary, rest/binary
</code></pre>
<p>Matches a binary of at least <code>2 + len</code> bytes, binds an unsigned 16-bit
integer as <code>len</code>, ignores the next <code>len</code> bytes, and binds the
remaining (possibly zero-length) binary as <code>rest</code>.</p>
<pre><code>s:8, key:s/binary, value/binary
</code></pre>
<p>When given the environment <code>{s:6, key: &quot;foobar&quot;}</code>, will match a binary
starting with [6, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, ...].</p>
</div>
  </div>
</body>
</html>
