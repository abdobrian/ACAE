<!DOCTYPE html>
<html>
<head>
  <title>index.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../doc-style.css" />
  <script src="../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../";
    var thisFile = "ClientApp\\node_modules\\combine-lists\\index.js";
    var defaultSidebar = true;
  </script>
  <script src="../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>index.js</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lodash'</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<div class="dox">
<div class="summary">
<p>Merge two lists, removing duplicates, and doing everything possible to
maintain the order of the two lists.</p>
</div>
<div class="body">
<p>This function guarantees that the order of list1 is preserved (that is, if x
comes before y in list1, x comes before y in the returned list) and tries
not to undo the order of list2, though sometimes it is unavoidable.</p>
<p>For example, if we have list1 = [1, 2, 4] and list2 = [2, 1, 3, 4], then the
merged list would be [1, 2, 3, 4], since that preserves the order of list1
while doing the best job possible of preserving the order of list2.</p>
<p>A case like list1 = [1, 3], list2 = [3, 2, 1] is more complicated.  It's not
clear what the best merged list is, but it's probably either [2, 1, 3] or
[1, 3, 2].</p>
<p>In general, it's not totally clear what the &quot;best&quot; merged list is, but there
are some basic properties that anyone would expect:</p>
<ul>
<li>Since the order of list1 is preserved, the merged list will look like
list1 with the elements exclusive to list2 inserted in betweeen</li>
<li>If list2[i] is not in list1, and it is possible to insert list2[i] into
list1 without contradicting the order of list2, then it should be
inserted in such a way</li>
</ul>
<p>This is very slow, crossing the 100ms mark with lists around 150 in length,
and growing at a rate of
O(list2.length<em>list2.length</em>(list1.length + list2.length)) from there.</p>
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">list1</span>
<span class="dox_type">Array.&lt;*&gt;</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">list2</span>
<span class="dox_type">Array.&lt;*&gt;</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">Array.&lt;*&gt;</span>
<span>A list containing all the elements of list1 and list2,      with duplicates removed, the order of list1 preserved, and the order of
list2 partially preserved
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">list1, list2</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<div class="dox">
<div class="summary">
<p>This is going to get mathematical.  As noted above, the merged list will be
a copy of list1 with the items exclusive to list2 inserted in between.  But
additionally, we want to preserve the order of list2 as much as possible.
In more formal terms, for all x and y from list2, we want to minimize the
number of times that x is before y in the merged list but after y in list2.
We call each such time an &quot;inversion&quot;, after the term in discrete math.</p>
</div>
<div class="body">
<p>We are going to take a greedy approach to this:</p>
<p>merged_list = a copy of list1
for(i = 0; i &lt; list2.length; i++)
if(list2[i] is not in list1)
insert list2[i] into merged_list in the earliest place that creates the
minimum number of inversions
return merged_list</p>
<p>It can be proven that this gives you the two properties mentioned in the
header comment above</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> merged = list1.slice(); <span class="hljs-comment">// The merged list to return</span>
  <span class="hljs-keyword">var</span> mergedIndexes = _.invert(merged);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; list2.length; i++) {
    <span class="hljs-keyword">var</span> elem = list2[i];
    <span class="hljs-keyword">if</span> (mergedIndexes[elem] === <span class="hljs-literal">undefined</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<p>Count the inversions for every possible insertion position</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> inversionCnts = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Int32Array</span> !== <span class="hljs-string">'undefined'</span> ?
          <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int32Array</span>(merged.length + <span class="hljs-number">1</span>) :
          _.fill(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(merged.length + <span class="hljs-number">1</span>), <span class="hljs-number">0</span>);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; list2.length; j++) {
        <span class="hljs-keyword">var</span> jMergedIndex = mergedIndexes[list2[j]];
        <span class="hljs-keyword">if</span> (j &lt; i) {
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k = <span class="hljs-number">0</span>; k &lt;= jMergedIndex; k++) {
            inversionCnts[k]++;
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (jMergedIndex !== <span class="hljs-literal">undefined</span>) { <span class="hljs-comment">// j &gt; i</span>
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k = jMergedIndex + <span class="hljs-number">1</span>; k &lt; inversionCnts.length; k++) {
            inversionCnts[k]++;
          }
        }
      }

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<p>Pick the earliest place that creates the minimum number of inversions</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> minInversionIndex = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">1</span>; j &lt; inversionCnts.length; j++) {
        <span class="hljs-keyword">if</span> (inversionCnts[j] &lt; inversionCnts[minInversionIndex]) {
          minInversionIndex = j;
        }
      }
      merged.splice(minInversionIndex, <span class="hljs-number">0</span>, elem);
      mergedIndexes = _.invert(merged);
    }
  }
  <span class="hljs-keyword">return</span> merged;
};

</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
