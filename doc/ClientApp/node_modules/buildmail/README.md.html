<!DOCTYPE html>
<html>
<head>
  <title>README.md</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../../doc-style.css" />
  <script src="../../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../../";
    var thisFile = "ClientApp\\node_modules\\buildmail\\README.md";
    var defaultSidebar = true;
  </script>
  <script src="../../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

      <div class="heading h1">
        <a href="#buildmail">buildmail</a>
      </div>

      <div class="heading h2">
        <a href="#usage">Usage</a>
      </div>

      <div class="heading h2">
        <a href="#api">API</a>
      </div>

      <div class="heading h2">
        <a href="#methods">Methods</a>
      </div>

      <div class="heading h3">
        <a href="#createchild">createChild</a>
      </div>

      <div class="heading h3">
        <a href="#appendchild">appendChild</a>
      </div>

      <div class="heading h2">
        <a href="#replace">replace</a>
      </div>

      <div class="heading h2">
        <a href="#remove">remove</a>
      </div>

      <div class="heading h2">
        <a href="#setheader">setHeader</a>
      </div>

      <div class="heading h2">
        <a href="#addheader">addHeader</a>
      </div>

      <div class="heading h2">
        <a href="#prepared-headers">Prepared headers</a>
      </div>

      <div class="heading h2">
        <a href="#getheader">getHeader</a>
      </div>

      <div class="heading h2">
        <a href="#buildheaders">buildHeaders</a>
      </div>

      <div class="heading h2">
        <a href="#setcontent">setContent</a>
      </div>

      <div class="heading h2">
        <a href="#setraw">setRaw</a>
      </div>

      <div class="heading h2">
        <a href="#build">build</a>
      </div>

      <div class="heading h2">
        <a href="#createreadstream">createReadStream</a>
      </div>

      <div class="heading h2">
        <a href="#transform">transform</a>
      </div>

      <div class="heading h2">
        <a href="#setenvelope">setEnvelope</a>
      </div>

      <div class="heading h2">
        <a href="#getenvelope">getEnvelope</a>
      </div>

      <div class="heading h2">
        <a href="#messageid">messageId</a>
      </div>

      <div class="heading h2">
        <a href="#getaddresses">getAddresses</a>
      </div>

      <div class="heading h2">
        <a href="#notes">Notes</a>
      </div>

      <div class="heading h3">
        <a href="#addresses">Addresses</a>
      </div>

      <div class="heading h3">
        <a href="#attachments">Attachments</a>
      </div>

      <div class="heading h3">
        <a href="#mime-structure">MIME structure</a>
      </div>

      <div class="heading h2">
        <a href="#license">License</a>
      </div>

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="docs markdown"><div class="pilwrap" id="buildmail">
  <h1>
    <a href="#buildmail" name="buildmail" class="pilcrow"></a>
buildmail
  </h1>
</div>
<p>Low level rfc2822 message composer that streams output. Define your own mime tree, no magic included.</p>
<p>Ported from <a href="https://github.com/whiteout-io/mailbuild">MailBuild</a> of the <a href="http://emailjs.org/">emailjs.org</a> project. This port uses similar API but is for Node only and streams the output.</p>
<p><a href="http://travis-ci.org/nodemailer/buildmail"><img src="https://secure.travis-ci.org/nodemailer/buildmail.svg" alt="Build Status"></a>
<a href="http://badge.fury.io/js/buildmail"><img src="https://badge.fury.io/js/buildmail.svg" alt="NPM version" height="18"></a></p>
<div class="pilwrap" id="usage">
  <h2>
    <a href="#usage" name="usage" class="pilcrow"></a>
Usage
  </h2>
</div>
<p>Install with npm</p>
<pre><code>npm install buildmail
</code></pre>
<p>Require in your scripts</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> BuildMail = <span class="hljs-built_in">require</span>(<span class="hljs-string">'buildmail'</span>);
</code></pre>
<div class="pilwrap" id="api">
  <h2>
    <a href="#api" name="api" class="pilcrow"></a>
API
  </h2>
</div>
<p>Create a new <code>BuildMail</code> object with</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> builder = <span class="hljs-keyword">new</span> BuildMail(contentType [, options]);
</code></pre>
<p>Where</p>
<ul>
<li><strong>contentType</strong> - define the content type for created node. Can be left blank for attachments (content type derived from <code>filename</code> option if available)</li>
<li><strong>options</strong> - an optional options object
<ul>
<li><strong>filename</strong> - <em>String</em> filename for an attachment node</li>
<li><strong>baseBoundary</strong> - <em>String</em> shared part of the unique multipart boundary (generated randomly if not set)</li>
<li><strong>keepBcc</strong> - <em>Boolean</em> If true keep the Bcc value in generated headers (default is to remove it)</li>
<li><strong>textEncoding</strong> - set default content encoding, either 'base64' or 'quoted-printable'</li>
<li><strong>hostname</strong> - optional hostname for default Message-Id values. Normally hostname from the <code>from</code> address is used but this might not be available</li>
<li><strong>disableUrlAccess</strong> - if set to true then fails with an error when a node tries to load content from URL</li>
<li><strong>disableFileAccess</strong> - if set to true then fails with an error when a node tries to load content from a file</li>
</ul>
</li>
</ul>
<div class="pilwrap" id="methods">
  <h2>
    <a href="#methods" name="methods" class="pilcrow"></a>
Methods
  </h2>
</div>
<p>The same methods apply to the root node created with <code>new BuildMail()</code> and to any child nodes.</p>
<div class="pilwrap" id="createchild">
  <h3>
    <a href="#createchild" name="createchild" class="pilcrow"></a>
createChild
  </h3>
</div>
<p>Creates and appends a child node to the node object</p>
<pre><code class="javascript">node.createChild(contentType, options)
</code></pre>
<p>The same arguments apply as with <code>new BuildMail()</code>. Created node object is returned.</p>
<p><strong>Example</strong></p>
<pre><code class="javascript"><span class="hljs-keyword">new</span> BuildMail(<span class="hljs-string">'multipart/mixed'</span>).
    createChild(<span class="hljs-string">'multipart/related'</span>).
        createChild(<span class="hljs-string">'text/plain'</span>);
</code></pre>
<p>Generates the following mime tree:</p>
<pre><code>multipart/mixed
  ↳ multipart/related
      ↳ text/plain
</code></pre>
<div class="pilwrap" id="appendchild">
  <h3>
    <a href="#appendchild" name="appendchild" class="pilcrow"></a>
appendChild
  </h3>
</div>
<p>Appends an existing child node to the node object. Removes the node from an existing tree if needed.</p>
<pre><code class="javascript">node.appendChild(childNode)
</code></pre>
<p>Where</p>
<ul>
<li><strong>childNode</strong> - child node to be appended</li>
</ul>
<p>Method returns appended child node.</p>
<p><strong>Example</strong></p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> childNode = <span class="hljs-keyword">new</span> BuildMail(<span class="hljs-string">'text/plain'</span>),
    rootNode = <span class="hljs-keyword">new</span> BuildMail(<span class="hljs-string">'multipart/mixed'</span>);
rootnode.appendChild(childNode);
</code></pre>
<p>Generates the following mime tree:</p>
<pre><code>multipart/mixed
  ↳ text/plain
</code></pre>
<div class="pilwrap" id="replace">
  <h2>
    <a href="#replace" name="replace" class="pilcrow"></a>
replace
  </h2>
</div>
<p>Replaces current node with another node</p>
<pre><code class="javascript">node.replace(replacementNode)
</code></pre>
<p>Where</p>
<ul>
<li><strong>replacementNode</strong> - node to replace the current node with</li>
</ul>
<p>Method returns replacement node.</p>
<p><strong>Example</strong></p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> rootNode = <span class="hljs-keyword">new</span> BuildMail(<span class="hljs-string">'multipart/mixed'</span>),
    childNode = rootNode.createChild(<span class="hljs-string">'text/plain'</span>);
childNode.replace(<span class="hljs-keyword">new</span> BuildMail(<span class="hljs-string">'text/html'</span>));
</code></pre>
<p>Generates the following mime tree:</p>
<pre><code>multipart/mixed
  ↳ text/html
</code></pre>
<div class="pilwrap" id="remove">
  <h2>
    <a href="#remove" name="remove" class="pilcrow"></a>
remove
  </h2>
</div>
<p>Removes current node from the mime tree. Does not make a lot of sense for a root node.</p>
<pre><code class="javascript">node.remove();
</code></pre>
<p>Method returns removed node.</p>
<p><strong>Example</strong></p>
<pre><code class="javascript">
<span class="hljs-keyword">var</span> rootNode = <span class="hljs-keyword">new</span> BuildMail(<span class="hljs-string">'multipart/mixed'</span>),
    childNode = rootNode.createChild(<span class="hljs-string">'text/plain'</span>);
childNode.remove();
</code></pre>
<p>Generates the following mime tree:</p>
<pre><code>multipart/mixed
</code></pre>
<div class="pilwrap" id="setheader">
  <h2>
    <a href="#setheader" name="setheader" class="pilcrow"></a>
setHeader
  </h2>
</div>
<p>Sets a header value. If the value for selected key exists, it is overwritten.</p>
<p>You can set multiple values as well by using <code>[{key:'', value:''}]</code> or
<code>{key: 'value'}</code> structures as the first argument.</p>
<pre><code class="javascript">node.setHeader(key, value);
</code></pre>
<p>Where</p>
<ul>
<li><strong>key</strong> - <em>String|Array|Object</em> Header key or a list of key value pairs</li>
<li><strong>value</strong> - <em>String</em> Header value</li>
</ul>
<p>Method returns current node.</p>
<p><strong>Example</strong></p>
<pre><code class="javascript"><span class="hljs-keyword">new</span> BuildMail(<span class="hljs-string">'text/plain'</span>).
    setHeader(<span class="hljs-string">'content-disposition'</span>, <span class="hljs-string">'inline'</span>).
    setHeader({
        <span class="hljs-string">'content-transfer-encoding'</span>: <span class="hljs-string">'7bit'</span>
    }).
    setHeader([
        {<span class="hljs-attr">key</span>: <span class="hljs-string">'message-id'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'abcde'</span>}
</code></pre>
<p>Generates the following header:</p>
<pre><code>Content-type: text/plain
Content-Disposition: inline
Content-Transfer-Encoding: 7bit
Message-Id: &lt;abcde&gt;
</code></pre>
<div class="pilwrap" id="addheader">
  <h2>
    <a href="#addheader" name="addheader" class="pilcrow"></a>
addHeader
  </h2>
</div>
<p>Adds a header value. If the value for selected key exists, the value is appended
as a new field and old one is not touched.</p>
<p>You can set multiple values as well by using <code>[{key:'', value:''}]</code> or
<code>{key: 'value'}</code> structures as the first argument.</p>
<pre><code class="javascript">node.addHeader(key, value);
</code></pre>
<p>Where</p>
<ul>
<li><strong>key</strong> - <em>String|Array|Object</em> Header key or a list of key value pairs</li>
<li><strong>value</strong> - <em>String</em> Header value or an array of strings to add the same key multiple times</li>
</ul>
<p>Method returns current node.</p>
<p><strong>Example</strong></p>
<pre><code class="javascript"><span class="hljs-keyword">new</span> BuildMail(<span class="hljs-string">'text/plain'</span>).
    addHeader(<span class="hljs-string">'X-Spam'</span>, <span class="hljs-string">'1'</span>).
    setHeader({
        <span class="hljs-string">'x-spam'</span>: <span class="hljs-string">'2'</span>
    }).
    setHeader([
        {<span class="hljs-attr">key</span>: <span class="hljs-string">'x-spam'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'3'</span>}
    ]);
</code></pre>
<p>Generates the following header:</p>
<pre><code>Content-type: text/plain
X-Spam: 1
X-Spam: 2
X-Spam: 3
</code></pre>
<div class="pilwrap" id="prepared-headers">
  <h2>
    <a href="#prepared-headers" name="prepared-headers" class="pilcrow"></a>
Prepared headers
  </h2>
</div>
<p>Normally all headers are encoded and folded to meet the requirement of having plain-ASCII messages with lines no longer than 78 bytes. Sometimes it is preferable to not modify header values and pass these as provided. This can be achieved with the <code>prepared</code> option:</p>
<pre><code class="javascript"><span class="hljs-keyword">new</span> BuildMail(<span class="hljs-string">'text/plain'</span>).
    addHeader(<span class="hljs-string">'X-Long-Header'</span>, {
        <span class="hljs-attr">prepared</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">value</span>: <span class="hljs-string">'a really long header or value with non-ascii characters 👮'</span>
    });

<span class="hljs-comment">// normal output:</span>
<span class="hljs-comment">// X-Long-Header: a really long header or value with non-ascii characters</span>
<span class="hljs-comment">//  =?UTF-8?Q?=F0=9F=91=AE?=</span>

<span class="hljs-comment">// output with the prepared option:</span>
<span class="hljs-comment">// X-Long-Header: a really long header or value with non-ascii characters 👮</span>
</code></pre>
<div class="pilwrap" id="getheader">
  <h2>
    <a href="#getheader" name="getheader" class="pilcrow"></a>
getHeader
  </h2>
</div>
<p>Retrieves the first mathcing value of a selected key</p>
<pre><code class="javascript">node.getHeader(key)
</code></pre>
<p>Where</p>
<ul>
<li><strong>key</strong> - <em>String</em> Key to search for</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="javascript"><span class="hljs-keyword">new</span> BuildMail(<span class="hljs-string">'text/plain'</span>).getHeader(<span class="hljs-string">'content-type'</span>); <span class="hljs-comment">// text/plain</span>
</code></pre>
<div class="pilwrap" id="buildheaders">
  <h2>
    <a href="#buildheaders" name="buildheaders" class="pilcrow"></a>
buildHeaders
  </h2>
</div>
<p>Builds the current header info into a header block that can be used in an e-mail</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> headers = node.buildHeaders()
</code></pre>
<p><strong>Example</strong></p>
<pre><code class="javascript"><span class="hljs-keyword">new</span> BuildMail(<span class="hljs-string">'text/plain'</span>).
    addHeader(<span class="hljs-string">'X-Spam'</span>, <span class="hljs-string">'1'</span>).
    setHeader({
        <span class="hljs-string">'x-spam'</span>: <span class="hljs-string">'2'</span>
    }).
    setHeader([
        {<span class="hljs-attr">key</span>: <span class="hljs-string">'x-spam'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'3'</span>}
    ]).buildHeaders();
</code></pre>
<p>returns the following String</p>
<pre><code>Content-Type: text/plain
X-Spam: 3
Date: Sat, 21 Jun 2014 10:52:44 +0000
Message-Id: &lt;1403347964894-790a5296-0eb7c7c7-6440334f@localhost&gt;
MIME-Version: 1.0
</code></pre>
<p>If the node is the root node, then <code>Date</code> and <code>Message-Id</code> values are generated automatically if missing</p>
<div class="pilwrap" id="setcontent">
  <h2>
    <a href="#setcontent" name="setcontent" class="pilcrow"></a>
setContent
  </h2>
</div>
<p>Sets body content for current node. If the value is a string and Content-Type is text/* then charset is set automatically.
If the value is a Buffer or a Stream you need to specify the charset yourself.</p>
<pre><code class="javascript">node.setContent(body)
</code></pre>
<p>Where</p>
<ul>
<li><strong>body</strong> - <em>String|Buffer|Stream|Object</em> body content</li>
</ul>
<p>If the value is an object, it should include one of the following properties</p>
<ul>
<li><strong>path</strong> - path to a file that will be used as the content</li>
<li><strong>href</strong> - URL that will be used as the content</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="javascript"><span class="hljs-keyword">new</span> BuildMail(<span class="hljs-string">'text/plain'</span>).setContent(<span class="hljs-string">'Hello world!'</span>);

<span class="hljs-keyword">new</span> BuildMail(<span class="hljs-string">'text/plain; charset=utf-8'</span>).setContent(fs.createReadStream(<span class="hljs-string">'message.txt'</span>));
</code></pre>
<div class="pilwrap" id="setraw">
  <h2>
    <a href="#setraw" name="setraw" class="pilcrow"></a>
setRaw
  </h2>
</div>
<p>Sets pre-generated output value for current node. When building the final message
then this value is returned instead of building a fresh rfc822 mime message from
normal input.</p>
<p>This also means that other methods (<code>getAddresses</code>, <code>getEnvelope</code> etc.) that use normal
input do not return valid values as the raw message is not parsed. You must set
envelope contents manually with <code>setEnvelope</code> and you probably should set the
<em>Message-Id</em> header (even though it wouldn't break anything if you would not set it).</p>
<pre><code class="javascript">node.setRaw(message)
</code></pre>
<p>Where</p>
<ul>
<li><strong>message</strong> - <em>String|Buffer|Stream|Object</em> MIME message</li>
</ul>
<p>If the value is an object, it should include one of the following properties</p>
<ul>
<li><strong>path</strong> - path to a file that will be used as the content</li>
<li><strong>href</strong> - URL that will be used as the content</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="javascript"><span class="hljs-keyword">new</span> BuildMail().setRaw(fs.createReadStream(<span class="hljs-string">'message.eml'</span>));
</code></pre>
<div class="pilwrap" id="build">
  <h2>
    <a href="#build" name="build" class="pilcrow"></a>
build
  </h2>
</div>
<p>Builds the rfc2822 message from the current node. If this is a root node, mandatory header fields are set if missing (Date, Message-Id, MIME-Version)</p>
<pre><code class="javascript">node.build(callback)
</code></pre>
<p>Callback returns the rfc2822 message as a Buffer</p>
<p><strong>Example</strong></p>
<pre><code class="javascript"><span class="hljs-keyword">new</span> BuildMail(<span class="hljs-string">'text/plain'</span>).setContent(<span class="hljs-string">'Hello world!'</span>).build(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, mail</span>)</span>{
    <span class="hljs-built_in">console</span>.log(mail.toString(<span class="hljs-string">'ascii'</span>));
});
</code></pre>
<p>Returns the following string:</p>
<pre><code>Content-type: text/plain
Date: &lt;current datetime&gt;
Message-Id: &lt;generated value&gt;
MIME-Version: 1.0

Hello world!
</code></pre>
<div class="pilwrap" id="createreadstream">
  <h2>
    <a href="#createreadstream" name="createreadstream" class="pilcrow"></a>
createReadStream
  </h2>
</div>
<p>If you manage large attachments you probably do not want to generate but stream the message.</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> stream = node.createReadStream(options)
</code></pre>
<p>Where</p>
<ul>
<li><strong>options</strong> - <em>Object</em> optional Stream options (ie. <code>highWaterMark</code>)</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> message = <span class="hljs-keyword">new</span> BuildMail();
message.addHeader({
    <span class="hljs-attr">from</span>: <span class="hljs-string">'From &lt;from@example.com&gt;'</span>,
    <span class="hljs-attr">to</span>: <span class="hljs-string">'receiver1@example.com'</span>,
    <span class="hljs-attr">cc</span>: <span class="hljs-string">'receiver2@example.com'</span>
});
message.setContent(fs.createReadStream(<span class="hljs-string">'message.txt'</span>));
message.createReadStream().pipe(fs.createWriteStream(<span class="hljs-string">'message.eml'</span>));
</code></pre>
<div class="pilwrap" id="transform">
  <h2>
    <a href="#transform" name="transform" class="pilcrow"></a>
transform
  </h2>
</div>
<p>If you want to modify the created stream, you can add transform streams that the output will be piped through.</p>
<pre><code class="javascript">node.transform(transformStream)
</code></pre>
<p>Where</p>
<ul>
<li><strong>transformStream</strong> - <em>Stream</em> or <em>Function</em> Transform stream that the output will go through before returing with <code>createReadStream</code>. If the value is a function the function should return a transform stream object when called.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> PassThrough = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>).PassThrough;
<span class="hljs-keyword">var</span> message = <span class="hljs-keyword">new</span> BuildMail();
message.addHeader({
    <span class="hljs-attr">from</span>: <span class="hljs-string">'From &lt;from@example.com&gt;'</span>,
    <span class="hljs-attr">to</span>: <span class="hljs-string">'receiver1@example.com'</span>,
    <span class="hljs-attr">cc</span>: <span class="hljs-string">'receiver2@example.com'</span>
});
message.setContent(fs.createReadStream(<span class="hljs-string">'message.txt'</span>));
message.transform(<span class="hljs-keyword">new</span> PassThrough()); <span class="hljs-comment">// add a stream that the output will be piped through</span>
message.createReadStream().pipe(fs.createWriteStream(<span class="hljs-string">'message.eml'</span>));
</code></pre>
<div class="pilwrap" id="setenvelope">
  <h2>
    <a href="#setenvelope" name="setenvelope" class="pilcrow"></a>
setEnvelope
  </h2>
</div>
<p>Set envelope object to use. If one is not set, it is generated based ong the headers.</p>
<pre><code class="javascript">node.setEnvelope(envelope)
</code></pre>
<p>Where</p>
<ul>
<li><strong>envelope</strong> is an envelope object in the form of <code>{from:'address', to: ['addresses']}</code></li>
</ul>
<div class="pilwrap" id="getenvelope">
  <h2>
    <a href="#getenvelope" name="getenvelope" class="pilcrow"></a>
getEnvelope
  </h2>
</div>
<p>Generates a SMTP envelope object. Makes sense only for root node.</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> envelope = node.generateEnvelope()
</code></pre>
<p>Method returns the envelope in the form of <code>{from:'address', to: ['addresses']}</code></p>
<p><strong>Example</strong></p>
<pre><code class="javascript"><span class="hljs-keyword">new</span> BuildMail().
    addHeader({
        <span class="hljs-attr">from</span>: <span class="hljs-string">'From &lt;from@example.com&gt;'</span>,
        <span class="hljs-attr">to</span>: <span class="hljs-string">'receiver1@example.com'</span>,
        <span class="hljs-attr">cc</span>: <span class="hljs-string">'receiver2@example.com'</span>
    }).
    getEnvelope();
</code></pre>
<p>Returns the following object:</p>
<pre><code class="javascript">{
    <span class="hljs-attr">from</span>: <span class="hljs-string">'from@example.com'</span>,
    <span class="hljs-attr">to</span>: [<span class="hljs-string">'receiver1@example.com'</span>, <span class="hljs-string">'receiver2@example.com'</span>]
}
</code></pre>
<div class="pilwrap" id="messageid">
  <h2>
    <a href="#messageid" name="messageid" class="pilcrow"></a>
messageId
  </h2>
</div>
<p>Returns Message-Id value. If it does not exist then generates one.</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> messageId = node.messageId();
</code></pre>
<p>Method returns the Message-Id value <code>&lt;unique-message-id@example.com</code></p>
<p><strong>Example</strong></p>
<pre><code class="javascript"><span class="hljs-keyword">new</span> BuildMail().
    addHeader({
        <span class="hljs-attr">from</span>: <span class="hljs-string">'From &lt;from@example.com&gt;'</span>
    }).
    messageId();
</code></pre>
<p>Returns the following value:</p>
<pre><code class="javascript"><span class="hljs-string">"&lt;1453237212620-0657660b-8df9255d-18bcdcb5@example.com&gt;"</span>
</code></pre>
<div class="pilwrap" id="getaddresses">
  <h2>
    <a href="#getaddresses" name="getaddresses" class="pilcrow"></a>
getAddresses
  </h2>
</div>
<p>Returns an address container object. Includes all parsed addresses from From, Sender, To, Cc, Bcc and Reply-To fields.</p>
<p>While <code>getEnvelope()</code> returns 'from' value as a single address (the first one encountered) then <code>getAddresses</code> return all values as arrays, including <code>from</code>. Additionally while <code>getEnvelope</code> returns only <code>from</code> and a combined <code>to</code> value then <code>getAddresses</code> returns all fields separately.</p>
<p>Possbile return values (all arrays in the form of <code>[{name:'', address:''}]</code>):</p>
<ul>
<li><strong>from</strong></li>
<li><strong>sender</strong></li>
<li><strong>'reply-to'</strong></li>
<li><strong>to</strong></li>
<li><strong>cc</strong></li>
<li><strong>bcc</strong></li>
</ul>
<p>If no addresses were found for a particular field, the field is not set in the response object.</p>
<p><strong>Example</strong></p>
<pre><code class="javascript"><span class="hljs-keyword">new</span> BuildMail().
    addHeader({
        <span class="hljs-attr">from</span>: <span class="hljs-string">'From &lt;from@example.com&gt;'</span>,
        <span class="hljs-attr">to</span>: <span class="hljs-string">'"Receiver" receiver1@example.com'</span>,
        <span class="hljs-attr">cc</span>: <span class="hljs-string">'receiver2@example.com'</span>
    }).
    getAddresses();
</code></pre>
<p>Returns the following object:</p>
<pre><code class="javascript">{
    <span class="hljs-attr">from</span>: [{
        <span class="hljs-attr">name</span>: <span class="hljs-string">'From'</span>,
        <span class="hljs-attr">address</span>: <span class="hljs-string">'from@example.com'</span>
    }],
    <span class="hljs-attr">to</span>: [{
        <span class="hljs-attr">name</span>: <span class="hljs-string">'Receiver'</span>,
        <span class="hljs-attr">address</span>: <span class="hljs-string">'receiver1@example.com'</span>
    }],
    <span class="hljs-attr">cc</span>: [{
        <span class="hljs-attr">name</span>: <span class="hljs-string">''</span>,
        <span class="hljs-attr">address</span>: <span class="hljs-string">'receiver2@example.com'</span>
    }]
}
</code></pre>
<div class="pilwrap" id="notes">
  <h2>
    <a href="#notes" name="notes" class="pilcrow"></a>
Notes
  </h2>
</div>
<div class="pilwrap" id="addresses">
  <h3>
    <a href="#addresses" name="addresses" class="pilcrow"></a>
Addresses
  </h3>
</div>
<p>When setting address headers (<code>From</code>, <code>To</code>, <code>Cc</code>, <code>Bcc</code>) use of unicode is allowed. If needed
the addresses are converted to punycode automatically.</p>
<div class="pilwrap" id="attachments">
  <h3>
    <a href="#attachments" name="attachments" class="pilcrow"></a>
Attachments
  </h3>
</div>
<p>For attachments you should minimally set <code>filename</code> option and <code>Content-Disposition</code> header. If filename is specified, you can leave content type blank - if content type is not set, it is detected from the filename.</p>
<pre><code class="javascript"><span class="hljs-keyword">new</span> BuildMail(<span class="hljs-string">'multipart/mixed'</span>).
  createChild(<span class="hljs-literal">false</span>, {<span class="hljs-attr">filename</span>: <span class="hljs-string">'image.png'</span>}).
  setHeader(<span class="hljs-string">'Content-Disposition'</span>, <span class="hljs-string">'attachment'</span>);
</code></pre>
<p>Obviously you might want to add <code>Content-Id</code> header as well if you want to reference this attachment from the HTML content.</p>
<div class="pilwrap" id="mime-structure">
  <h3>
    <a href="#mime-structure" name="mime-structure" class="pilcrow"></a>
MIME structure
  </h3>
</div>
<p>Most probably you only need to deal with the following multipart types when generating messages:</p>
<ul>
<li><strong>multipart/alternative</strong> - includes the same content in different forms (usually text/plain + text/html)</li>
<li><strong>multipart/related</strong> - includes main node and related nodes (eg. text/html + referenced attachments). Also requires a <code>type</code> parameter that indicates the Content-Type of the <em>root</em> element in the node</li>
<li><strong>multipart/mixed</strong> - includes other multipart nodes and attachments, or single content node and attachments</li>
</ul>
<p><strong>Examples</strong></p>
<p>One content node and an attachment</p>
<pre><code>multipart/mixed
  ↳ text/plain
  ↳ image/png
</code></pre>
<p>Content node with referenced attachment (eg. image with <code>Content-Type</code> referenced by <code>cid:</code> url in the HTML)</p>
<pre><code>multipart/related
  ↳ text/html
  ↳ image/png
</code></pre>
<p>Plaintext and HTML alternatives</p>
<pre><code>multipart/alternative
  ↳ text/html
  ↳ text/plain
</code></pre>
<p>One content node with referenced attachment and a regular attachment</p>
<pre><code>multipart/mixed
  ↳ multipart/related
    ↳ text/plain
    ↳ image/png
  ↳ application/x-zip
</code></pre>
<p>Alternative content with referenced attachment for HTML and a regular attachment</p>
<pre><code>multipart/mixed
  ↳ multipart/alternative
    ↳ text/plain
    ↳ multipart/related
      ↳ text/html
      ↳ image/png
  ↳ application/x-zip
</code></pre>
<div class="pilwrap" id="license">
  <h2>
    <a href="#license" name="license" class="pilcrow"></a>
License
  </h2>
</div>
<p><strong>MIT</strong></p>
</div>
  </div>
</body>
</html>
